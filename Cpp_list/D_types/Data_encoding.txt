Существует 2 метода кодирования инормации для переменных в C++.
Оба способа зависят от модификатора типа данных переменной.

1) Signed(Знаковый тип)

В знаковых типах старший бит используется в качестве флага знака.
Если флаг равен 0, число считается положительным, а если 1 — отрицательным.
Отрицательные числа почти всегда представляются в дополнительном коде.
Для его получения все биты числа инвертируются (переводятся в обратный код),
а затем результат увеличивается на единицу.

В языке C++ unsigned int — это беззнаковый целочисленный тип, который подразумевает,
что переменная может хранить только неотрицательные значения.

Знаковые целочисленные значения используются во многих алгоритмах,
но их абсолютная величина в два раза меньше, чем у их беззнаковых аналогов.
Рассмотрим, например, максимально возможное 16-битное целое число со знаком: 32767.

```
unsigned int x;
unsigned int y;
```

Его двоичное представление:

```
01111111 11111111
```

Если бы старший бит этого значения со знаком был установлен в 1, то оно интерпретировалось
бы как -1 (в дополнительном коде). Но если объявить его как значение типа unsigned int, 
то при установке старшего бита в 1 мы получим число 65535.

2) Unsigned(Беззнаковый)

Беззнаковая арифметика в C++ определяется стандартом как арифметика по модулю 2ⁿ, где
n — количество бит в типе. Это предсказуемое поведение.

Пример: переполнение вверх

```
unsigned char a = 255; // binary: 11111111
a = a + 1;            // Результат: 0 (binary: 00000000)
```

Битовый уровень:

  11111111 (255)
+ 00000001 (1)
----------
 100000000 (256)  // 9 бит - выход за границы 8-битного char
           ↓
  00000000 (0)    // Старший бит отбрасывается, остается 8 младших


Пример: недополнение вниз

```
unsigned char b = 0;
b = b - 1; // Результат: 255 (binary: 11111111)
```

Битовый уровень:

  00000000 (0)
- 00000001 (1)
----------
  (заем) происходит заем из несуществующего старшего бита
  11111111 (255) // Как если бы было 100000000 - 1 = 11111111
